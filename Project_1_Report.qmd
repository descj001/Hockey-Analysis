---
title: "Hockey Analytics: Predicting Goals and Finding the NHL's Best Shooters"
format:
  html:
    toc: true
    html-math-method: mathjax
    css: styles.css
editor: visual
editor_options: 
  chunk_output_type: inline
---

```{r, warning=FALSE,message=FALSE}
library(hockeyR)
library(tidyverse)
```

## Motivation

We decided to analyze play-by-play NHL data to answer the question of who the best goal scorers are in the league. We want to know who is scoring goals in situations that other players would most likely not, or who is missing goals when others would most likely score. We will do this by building 3 different models that predict expected goals scored on a play. We will test these models against each other to find which most accurately predicts the expected goals a player has on a play. We will then find the players from the 2023-2024 season who had the most goals over expected in our models, to best answer the question of who were the most skilled goal scorers in that season.

## Data Preparation

We will be using [HockeyR's](https://hockeyr.netlify.app/) play-by-play data to answer these questions. We will use the 2020-2023 seasons to train our models and the 2023-2024 season to test them. Here we will load in all the play by play data for all the seasons

::: callout-important
## Warning

This chunk will take a longer download time.
:::

```{r}
pbp20 = load_pbp('2020-21')
pbp21 = load_pbp('2021-22')
pbp22 = load_pbp('2022-23')
pbp23 = load_pbp('2023-24')
```

We will then modify our 2023-2024 season data to match the previous seasons. The most recent seasons have a different column name for secondary_type, as well as different formatting for the values in that column. We change these to be consistent across all our data. We will also split into train and test sets.

```{r}
pbp_train <- bind_rows(pbp20, pbp21, pbp22) #<1>
pbp_test <- pbp23 #<2>
pbp_test <- pbp_test %>%
  dplyr::select(-secondary_type) %>%
  dplyr::rename(secondary_type = shotType) #<3>
pbp_test <- pbp_test |> 
  dplyr::mutate(
    secondary_type = dplyr::case_when( #<4>
      secondary_type == "wrist" ~ "Wrist Shot",
      secondary_type == "backhand" ~ "Backhand",
      secondary_type == "snap" ~ "Snap Shot",
      secondary_type == "slap" ~ "Slap Shot",
      secondary_type == "tip-in" ~ "Tip-In",
      secondary_type == "wrap-around" ~ "Wrap-around",
      secondary_type == "deflected" ~ "Deflected",
      secondary_type == "poke" ~ "Poke",
      secondary_type == "bat" ~ "Batted",
      secondary_type == "between-legs" ~ "Between Legs",
      secondary_type == "cradle" ~ "Cradle",
      TRUE ~ secondary_type
    )
  )
```

1.  Combine 2020-2023 seasons into the training set.
2.  Use the 2023-24 season as testing set
3.  Drop the old secondary_type column and rename shotType to secondary_type
4.  Standardize shot type labels

## Model 1

We will prepare our training data for our first model. Our first model will find the average of goals scored for each shot type a player can take. We start by filtering by plays that were either shots or goals and adding a numerical column to "Y" to represent goals. We also keep a column of hockeyR's expected goals for each play that we will use to compare against our models. Here is a look at our data.

```{r}
pbp_model_1 <- pbp_train |> 
  dplyr::filter(event_type %in% c("SHOT", "GOAL")) |> #<1> 
  dplyr::select(event_type,secondary_type,event_player_1_name, xg) |> #<2>
  dplyr::mutate(Y = ifelse(event_type == "GOAL",1,0)) #<3>
head(pbp_model_1)
```

1.  Filtering plays to shots/goals only
2.  Select relevant columns
3.  Add numeric goal column

Next we will create a table that contains the shooting percentage for each shot type from our testing data. Our model will calculate shooting percentage as shown.

$$
\text{Shooting\%}_{\text{shot\_type}} 
= \frac{\sum \text{goals}_{\text{shot\_type}}}
       {\sum \left(\text{shots}_{\text{shot\_type}}\right)}
$$

```{r}
shots_model_1 <- pbp_model_1 |> 
  dplyr::group_by(secondary_type) |> #<1>
  dplyr::summarize(
    shots = n(), #<2>
    goals = sum(Y),#<3>
    shooting_pct = mean(Y), #<4>
    .groups = "drop"
  ) |> drop_na(secondary_type) #<5>
shots_model_1
```

1.  Group by shot type
2.  Count total shots
3.  Count total goals
4.  Calculate shooting percentage
5.  Remove rows with NA shot types

As we can see, penalty shots go in at a much higher rate than most other shots, which makes sense intuitively. Now we can add shooting_pct to our test data, and find what players in the 2023-2024 season have the most goals over expected using this model.

```{r}
model_1_test <- pbp_test |> 
  dplyr::filter(event_type %in% c("SHOT", "GOAL")) |> 
  dplyr::select(event_type, secondary_type, event_player_1_name) |> 
  dplyr::mutate(Y = ifelse(event_type == "GOAL", 1, 0)) |> 
  left_join(shots_model_1, by = "secondary_type")

goe_model_1 <- 
  model_1_test |> 
  dplyr::mutate(diff = Y - shooting_pct) |> #<1>
  dplyr::group_by(event_player_1_name) |>    #<2>
  dplyr::summarise(
    player = unique(event_player_1_name), 
    GOE = round(sum(diff),3), #<3>
    shots = dplyr::n(),
    goals = sum(Y)
  ) |> 
  dplyr::select(player, shots, goals, GOE) |>  #<4>
  dplyr::arrange(dplyr::desc(GOE)) #<5>

goe_model_1
```

1.  Calculate goal difference from expected
2.  Group by player
3.  Sum GOE
4.  Select final columns
5.  Sort by GOE descending

We can see big scorers like Auston Matthews and Leon Draisatil appear on our list. However, there may be some issues with this model. Since we are only predicting on shot types, a wrist shot from the blue line and a wrist shot a foot away from the net will have the same chance of going in, according to this model.

## Model 2

Model 2 will add more parameters than Model 1, and it will use logistic regression in order to predict expected goals. The parameters we will use for this model will be shot type, distance from the goal, and shot angle. Shot distance is measured in feet away from the goal. Shot angle is at 0 when a shot is taken directly in front of a goalie and goes to 90 when a shot is taken from the goal line on the right or the left. We will filter our data again by shots and goals and add a numerical goal column like we did in model 1.

```{r}
pbp_model_2 <- pbp_train |> 
  dplyr::select(xg, season, description, event_type, event, secondary_type,shot_distance, shot_angle, event_player_1_name, event_player_1_id) |> 
  dplyr::filter(event_type %in% c("SHOT", "GOAL")) |> 
  dplyr::mutate(Y = ifelse(event_type == "GOAL", 1, 0))
pbp_model_2
```

We will then build a logistic regression model with our 3 parameters as mentioned before

```{r}
model_2_fit <- glm(formula = Y~shot_distance + shot_angle + secondary_type, data = pbp_model_2, family = binomial("logit"))
model_2_fit
```

Our model predicts that as shot distance and angle increase, the chances of a shot going in will decrease, which makes sense intuitively. We will now use this model to predict the expected goal for all shots and goals of the 2023-2024 season and find the players with the highest goals over expected using this model.

```{r}
model_2_test <- pbp_test |> 
  dplyr::filter(event_type %in% c("SHOT", "GOAL")) |> 
  dplyr::select(description, event_type, event, secondary_type,shot_distance, shot_angle, event_player_1_name, event_player_1_id) |> 
  dplyr::mutate(Y = ifelse(event_type == "GOAL", 1, 0)) |> 
  left_join(shots_model_1, by = "secondary_type")

model_2_test <- model_2_test |> 
  dplyr::mutate(xg2 = predict(model_2_fit, newdata = model_2_test, type="response")) |> #<1>
  drop_na(xg2) 

model_2_test <- model_2_test |> 
  dplyr::mutate(GOE_ON_PLAY = Y - xg2) #<2>

goe_model_2 <- model_2_test |> 
  dplyr::group_by(event_player_1_name) |> 
  dplyr::summarise(
    GOE = sum(GOE_ON_PLAY),
    shots = n(),
    goals = sum(Y),
    .groups = "drop"
  ) |> 
  dplyr::mutate(GOE = round(GOE, 3)) |>
  dplyr::select(player = event_player_1_name, goals, shots, GOE) |> #<3>
  dplyr::arrange(desc(GOE))
goe_model_2
```

1.  Predict expected goals for each shot using the model 2 fit; remove rows where prediction fails (NA)
2.  Calculate GOE for each shot
3.  Renaming column for clarity and select relevant columns

Our list of leaders still has the big names like our model 1 list did. However, their goals over expected have appeared to decrease a little bit. This could be because they are getting less goals over expected for goals made close and in front of the goalie which are where most goals in hockey are scored from.

## Model 3

Our third model will add 2 more predictors on top of what we used in model 2. In addition to shot type, shot distance, and shot angle we will also be using goalie save percentage for the goalie the shot was taken on, as well as the strength of the scoring team. Here we will begin filtering our data for this.

```{r}
pbp_model_3 <- pbp_train |> 
  dplyr::select(xg, season, description, event_type, event, secondary_type, event_goalie_name, event_goalie_id, strength_code, strength, shot_distance, shot_angle, event_player_1_name, event_player_1_id) |> 
  dplyr::filter(event_type %in% c("SHOT", "GOAL"))
pbp_model_3
```

Since hockeyR does not contain data for goalie save percentage, we will have to implement this column for our training and test data. We will find this number by taking the sum of plays a goalie is involved in a shot and divide it by the sum of plays a goalie is involved in a shot and a goal. We will remove NA goalies which represent empty nets since these will skew the sv_pct predictor.

```{r, message=FALSE}
goalies_train <- pbp_model_3 |> group_by(event_goalie_name, season) |> 
  dplyr::summarize(sv_pct = sum(event_type == "SHOT") / n()) #<1>


pbp_model_3 <- left_join(pbp_model_3, goalies_train, by = c("event_goalie_name", "season")) #<2>

pbp_model_3 <- pbp_model_3 |> 
  dplyr::mutate(Y = ifelse(event_type == "GOAL", 1, 0)) |> 
  dplyr::mutate(event_goalie_name = ifelse(is.na(event_goalie_name), "Empty Net", event_goalie_name)) #<3>
```

1.  Save % = shots saved / total shots faced
2.  Joining goalie save % back to pbp_model_3
3.  Fill missing goalie names with "Empty Net"

Once we have this attached to our data set we are able to fit a logistic regression model using shot distance, shot angle, shot type, sv_pct, and team strength

```{r}
model_3_fit <- glm(formula = Y~shot_distance + shot_angle + secondary_type + sv_pct + strength, data = pbp_model_3, family = binomial("logit")) #<1>
model_3_fit
```

1.  Fitting the logistic regression model using shot features + goalie save % + team strength

As you can see our coefficients are similar to our previous model. We also can see the significance of our new predictors for example goalie save percentage has a very strong negative impact on the chances of a shot going in. We also see that a shots chances of going in increase when a team is on a powerplay. Now we can add a save percentage column to our test data and find the goals over expected leaders for this model.

```{r}
model_3_test <- pbp_test |> 
  dplyr::select(description, event_type, event, secondary_type,
                event_goalie_name, event_goalie_id, strength_code, strength,
                shot_distance, shot_angle, event_player_1_name, event_player_1_id) |> 
  dplyr::filter(event_type %in% c("SHOT", "GOAL")) |> 
  dplyr::mutate(Y = ifelse(event_type == "GOAL", 1, 0))

goalies_test <- model_3_test |> 
  dplyr::group_by(event_goalie_name) |> 
  dplyr::summarize(sv_pct = sum(event_type == "SHOT") / n())



model_3_test <- left_join(model_3_test, goalies_test, by = c("event_goalie_name"))

model_3_test <- model_3_test |> 
  dplyr::mutate(Y = ifelse(event_type == "GOAL", 1, 0),
         event_goalie_name = ifelse(is.na(event_goalie_name), "Empty Net", event_goalie_name)) 

model_3_test <- model_3_test |> 
  dplyr::mutate(xg3 = predict(model_3_fit, newdata = model_3_test, type="response")) |> 
  drop_na(xg3)

model_3_test <- model_3_test |> 
  dplyr::mutate(GOE_ON_PLAY = Y - xg3) 

goe_model_3 <- model_3_test |> 
  dplyr::group_by(event_player_1_name) |> 
  dplyr::summarise(
    GOE = sum(GOE_ON_PLAY),
    shots = n(),
    goals = sum(Y),
    .groups = "drop"
  ) |> 
  dplyr::mutate(GOE = round(GOE, 3)) |>
  dplyr::select(player = event_player_1_name, goals, shots, GOE) |> 
  dplyr::arrange(desc(GOE))
goe_model_3
```

Here we see a similar list of players as before with Auston Matthews taking the top spot. We also see that in our top goal scores, GOE has gone down a bit.

## Model Comparison

To compare the performance of our models against each other we will find the log loss that is generated on the same test data for each model. This is a way to attribute a score to how far our predictions are compared to the actual results. We will also be testing our results against hockeyR's own xg model

```{r}
logloss <- function(y, phat){
  keep <- !is.na(y) & !is.na(phat)
  y <- y[keep]
  phat <- phat[keep]
  if(any(phat < 1e-12)) phat[phat < 1e-12] <- 1e-12 #<1>
  if(any(phat > 1 - 1e-12)) phat[phat > 1 - 1e-12] <- 1 - 1e-12
  return(-1 * mean(y * log(phat) + (1 - y) * log(1 - phat))) #<2>
}

cat("Model 1 Log Loss:",
    round(logloss(model_1_test$Y, model_1_test$shooting_pct), 3), "\n")

cat("Model 2 Log Loss:",
    round(logloss(model_2_test$Y, model_2_test$xg2), digits=3),"\n")

cat("Model 3 Log Loss:",
    round(logloss(model_3_test$Y, model_3_test$xg3), digits=3),"\n")

cat("NHL xG Log Loss:",
    round(logloss(pbp_model_1$Y, pbp_model_1$xg), 3), "\n")
```

1.  Avoid log(0)
2.  Log loss formula

As you can see our first model didn't do a great job in this test. This is likely because we used a single predictor that left out a lot of important factors about a shot. Our second model seemed to perform a bit better with the addition of distance and shot angle into our model. After adding 2 more important parameters goalie save percentage and team strength it appears that our model performed just as well on the 2023-2024 data as hockeyR's xg did on the 2020-2023 data.

## Findings

Let's take one more look at our GOE leaders for the 2023-2024 season, and take a deeper dive into Auston Matthews.

```{r}
pbp_matthews_goals <- model_3_test |> 
  dplyr::filter(event_player_1_name == "Auston Matthews") |> #<1>
  dplyr::filter(Y == 1) |> #<2>
  dplyr::arrange(desc(xg3)) #<3>
pbp_matthews_goals
```

1.  Keeping only Matthews' shots
2.  Only Keeping goals
3.  Sort by descending expected goals

As you can see, the 4 empty net goals he scored had a very high xg and we can see a steep dropoff on goals he scored when a goalie was in net. We can also see that his two longest goals of the year were made on empty nets yet the xg for these shots was very high. This shows our model does a good job recognizing when that shots taken with no goalie have a high chance to go in. We can also take a look at all of his shots and find which shots he generates more goals over expected with.

```{r}
pbp_matthews_shots <- model_3_test |> 
  dplyr::filter(event_player_1_name == "Auston Matthews",
                event_goalie_name != "Empty Net") |> 
  dplyr::group_by(secondary_type) |> 
  dplyr::summarise(GOE = sum(GOE_ON_PLAY),
                   shots = n()) |> 
  dplyr::arrange(desc(GOE))
pbp_matthews_shots
```

Here we can see that his signature go to shot is what generated him the most amount of GOE. Matthews is known for his toe-drag wrist shot that he can place any where he wants. Another interesting piece about this is how his slap shot generated his second most GOE. This might be attributed to the fact that Matthews generally sits on the wing during his teams power plays to take slap shots. Lets take a look at his slap shot goals

```{r}
matthews_slap_shot <- pbp_matthews_goals |> 
  dplyr::filter(secondary_type == "Slap Shot") |> 
  dplyr::select(strength, shot_distance, shot_angle, xg3, GOE_ON_PLAY)
matthews_slap_shot
```

As we can see, 9/10 of Matthews slap shot goals were on the teams power play. This shows how valuable of an asset he is during man-up situations.

## Improvements

Our model ended up attaining a log loss that was very similar to hockeyR's which is very exciting, however it still comes with downsides. One major downside was hockeyR adding shot types to the 2022-2023 season and beyond. As we can see here

```{r}
types_21 <- pbp21 |> 
  dplyr::filter(event_type %in% c("SHOT", "GOAL"))

cat("2021-2022 Shot types: ",
    unique(types_21$secondary_type), "\n\n")

cat("2022-2023 shot types: ",
    unique(model_1_test$secondary_type))

```

As we can see shots like Between Legs, Batted, and Poke were all added. This means when we trained our data on the 3 season before 2023-2024 ony 1 of them contained all of the relevant shots that 2023-2024 contained. In future development when more seasons are published with the same shot types we will be able to have uniform testing data. Another limitation that could have been a powerful feature would be a column containing defender information. If we had this information we could fine tune our model even more. Currently our model has no idea if there are 0 or 4 defenders between a shooter and the goal. This would be an important parameter because those extra defenders make scoring much more difficult.

## Next Steps

Future development would involve more testing on our final model. We could find the best shooters from certain spots on the ice by isolating distance and angle variables. We would also be able to make heat maps with this data by using sportsR to visualize the xg a shot has when taken from a certain point on the ice. This could be a powerful tool for coaches and players to not only know where to shoot to have the best chance of scoring, but they can also prioritize defending these hot zones. Our model could also be used to build profiles for specific players. Our report took a look at Auston Matthews and found how he was very efficent with slap shots on the power play. Opposing teams can use this information to combat offensive strengths of the best scorers in the league.
